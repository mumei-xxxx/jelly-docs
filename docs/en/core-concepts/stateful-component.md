# Dynamic Component

## Signal and Atom

`Signal` is a type to represent a value that changes over time.

And if `Signal` is the output, then `Atom` represents the input.
You can manipulate values with the `send` and `patch` functions.

`Signal` and `Atom` can be created using `signal` function.

Let's make a simple counter.

```purescript
module Example.Counter where

import Prelude

import Data.Tuple.Nested ((/\))
import Jelly.Data.Component (Component, el, el', text, textSig)
import Jelly.Data.Hooks (hooks)
import Jelly.Data.Prop (on)
import Jelly.Data.Signal (patch_, signal)
import Web.HTML.Event.EventTypes (click)

counterExample :: forall context. Component context
counterExample = hooks do
  countSig /\ countAtom <- signal 0

  pure do
    el "button" [ on click \_ -> patch_ countAtom (_ + 1) ] $ text "Increment"
    el "button" [ on click \_ -> patch_ countAtom (_ - 1) ] $ text "Decrement"
    el' "div" do
      text "Count: "
      textSig $ show <$> countSig

```

```preview
counter
```

## `signalEq` function

Signal and Atom pairs generated by the `signal` function are updated when the same value as the current value is submitted.
With the `signalEq` function, the pair will not be updated if the same value as the current value is submitted.

The types are as follows, respectively.

```purescript
signal :: forall m a. MonadEffect m => a -> m (Signal a /\ Atom a)
signalEq :: forall m a. MonadEffect m => Eq a => a -> m (Signal a /\ Atom a)
```

```preview
signalEq
```
